# -*- coding: utf-8 -*-
"""Lesson3_4_pandas & matplotlib & seaborn & plotly

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mFD6EvOjdvqGQDMRXEZYYLiKa3m1Lw40

## Introduction

In this lesson, we will learn about Pandas, a powerful library for data manipulation and analysis in Python. We will cover:

1. Introduction to Series
2. Basic methods and functions
3. Advanced methods
4. DataFrames
5. Handling missing data

## Pandas

### Series

A Series is an array of data paired with an array of indices. We will learn how to:
* Create a Series
* Access its elements
* Use basic methods and functions

1.   Voce elenco
2.   Voce elenco
"""

import numpy as np
import pandas as pd

"""## Creating a Series
How to create a Series in Pandas?




"""

my_list = [15, 25, 35]
vec = np.array(['Matteo', 'Sasa', 'Giacomo'])
d = {'a': 15, 'b': 25, 'c': 35}
labels = ['i', 'ii', 'iii']

dictionary_harry_potter = {'1': "The Philosophess Stone", '2': "The Chamber of Secrets", '3': "The Prisoner of Azkaban", '4': "The Goblet of Fire", '5': "The Order of the Phoenix", '6': "The Half-Blood Prince", '7': "The Deathly Hallows"}
pd.Series(dictionary_harry_potter)

"""By defining its data and indices, we can create a Series object.




"""

pd.Series(data=my_list)
pd.Series(data=my_list, index=labels)

pd.Series(data=vec)
pd.Series(data=vec, index=labels)

"""If we use a dictionary to create a Series, the keys are automatically used as indices.




"""

pd.Series(data=d)

"""The elements of a Series can be accessed in two ways, either with the same syntax as dictionaries (series['']) or as an array using indices (series[1]).




"""

serie = pd.Series(data=vec, index=labels)
print(serie['i'])
print(serie['ii'])
print(serie[0])

"""## Methods of Series
What methods do we have for Series?




"""

serie = serie.rename('Pippo')
print(serie)
print(serie.name)

"""A Series has a name, which will be useful when we insert it into a DataFrame, as it will become the column name in the latter.




"""

print(serie.values)
print(serie.index)

"""Series also have commands like head, tail, describe, etc., similar to those in the NumPy library.




"""

print(serie.head(2))
print(serie.tail(2))
print(serie.describe())

"""We can create a Series using NumPy functions like arange().




"""

serie_2 = pd.Series(np.arange(12) % 4)  # % is the modulo operation
print(serie_2)
print(serie_2.count())
print(serie_2.nunique())  # Count distinct observations along the specified axis
print(serie_2.unique())
print(serie_2.value_counts())

"""We can use NumPy functions on Series in a vectorized way.




"""

serie_3 = pd.Series(np.arange(7))

print(np.sin(serie_3))
print(np.cos(serie_3))

print(serie_3.mean())
print(serie_3.std())
print(serie_3.max())
print(serie_3.min())

"""## Advanced Series Methods

## Sort and Rank
Not all NumPy functions allow maintaining the indices of the Series. For example, with sort.
"""

serie_4 = pd.Series(np.arange(5, 0, -1))
serie_4

#print(serie_4)
print(np.sort(serie_4))
print(pd.Series(np.sort(serie_4)))

"""The indices remain the same, but they have different assigned values! How to fix this?




"""

print(serie_4)
print(serie_4.sort_values())
print(serie_4.sort_index())

"""To rank the values for a numerical Series, we can use rank.




"""

serie_4 = pd.Series([9, -5, 7, 1, 3])
print(serie_4)
print(serie_4.rank())  # 9 is the fifth number, -5 is the first

"""## Methods for ranking:

- average: average rank of the group
- min: lowest rank in the group
- max: highest rank in the group
- first: ranks assigned in the order they appear in the array
- dense: like min, but the rank always increases by 1 between groups.



"""

print(pd.Series([0, 1, 1, 1, 1, 2, 2.5, 3, 3]))

print(pd.Series([0, 1, 1, 1, 1, 2, 2.5, 3, 3]).rank())  # default average

print(pd.Series([0, 1, 1, 2]).rank(method='first'))  # rank assigned in the order it appears in the array
print(pd.Series([0, 1, 1, 7, 7, 7, 4, 4, 4, 3]).rank(method='max'))  # highest in the group
print(pd.Series([0, 1, 1, 7, 7, 7, 4, 4, 4]).rank(method='min'))  # lowest in the group
print(pd.Series([0, 1, 1, 7, 7, 7, 4, 4, 4]).rank(method='dense'))  # lowest in the group, increasing by one for each group

"""Reordering a Series based on the elements of another Series."""

serie_5 = pd.Series(np.arange(20, 25))
print(serie_5)
print(serie_4)
print(serie_5[serie_4.rank() - 1])

serie_4.rank() - 1

"""## Index Alignment, Apply, and Map
Index alignment is a procedure used by Pandas to perform operations between Series elements, utilizing the indices.




"""

serieA = pd.Series([41, 24, 23, 12], index=['France', 'Spain', 'Russia', 'Greece'])
serieB = pd.Series([63, 66, 55, 88], index=['France', 'Russia', 'Italy', 'Greece'])
print(serieA)
print(serieB)

print(serieA + serieB)

print(serieA * serieB)
print(serieA - serieB)
print(serieA % serieB)

"""## Applying Functions to a Series
Apply is a method used to apply a function to each element of the Series.




"""

serie = pd.Series([15, 44, 6], index=['1', '2', '3'])
print(serie)
print(serie.apply(lambda x: x**3 - x**2))
print(serie.apply(lambda x: x >= 43))

"""Another similar method is to use the map function. This method replaces all the values of a Series based on another Series, dictionary, or function.




"""

serie = pd.Series([15, 44, 6], index=['1', '2', '3'])
print(serie)
print(serie.map(pd.Series(['Giacomo', 'Matteo', 'Firenze'], index=[15, 6, 44])))
print(serie.map(lambda x: x**3 + 2*x))

"""Using a dictionary to map values in the Series.




"""

serie2 = serie.map(pd.Series(['Giacomo', 'Matteo', 'Firenze'], index=[15, 6, 44]))
print(serie2.map({'Giacomo': 'Jack', 'Matteo': 'Matthew', 'Firenze':"florence"}))

"""## Slicing Series
How to select only some elements from a Pandas Series? We can use NumPy commands like numeric range, boolean arrays, or index range as a sequence of strings.




"""

list('anastasia ')

serie = pd.Series(np.arange(9), index=list('anastasia'))
print(serie)
#print(serie.head(7))
#print(serie[2:4])
#print(serie[4::3])
#print(serie['n':'i':2])
#print(serie > 5)
#print(serie[serie > 5])
#print(serie[(serie < 2) | (serie > 7)])
print(serie[serie.isin([2, 8, 10, 15])])

"""Note: Be careful with negative indices, they can only be used if non-numeric indices were specified for the Series.




"""

print(pd.Series(np.arange(0, 7, 2), [0, 1, 2, 3]))  # [-2]
print(pd.Series(np.arange(0, 7, 2), [0, 1, 2, 3])[-2])  # it doesn't work
print(pd.Series(np.arange(0, 7, 2), list('erts')))
print(pd.Series(np.arange(0, 7, 2), list('erts'))[-2])
print(pd.Series(np.arange(0, 7, 2), list('erts'))[[-2]])

"""To remove elements from a Series, use the drop method.




"""

serie = pd.Series(np.arange(0, 7, 2), list('erts'))
print(serie)
print(serie.drop(['e', 's']))

serie2 = pd.Series(np.arange(0, 7, 2), list('erts'))
print(serie2.drop(['e', 's']))

"""## DataFrame
We will see how to create a DataFrame:

- From lists
- From Series
- From dictionaries

Let's start with the study of DataFrames. We will see how to create them.




"""

lista_elementi = [[228, 320, 360], ["1997", "1999", "1999"], ["1997", "1999", "1999"]]
list_index = ['pages', 'year of publication', 'year of publication']
list_columns = ["Harry Potter 1", "Harry Potter 2", "Harry Potter 3"]

df = pd.DataFrame(lista_elementi, list_index, list_columns)
print(df)

#print(df.info())

print(df.describe())





df = pd.DataFrame([[40, 50, 60], ["quaranta", "cinquanta", "sessanta"]], index=list('nl'), columns=list('asd'))
print(df)

np.random.seed(203)
array_random = np.random.rand(6)
print(array_random)
print(array_random.reshape(2, 3))

df2 = pd.DataFrame(array_random.reshape(2, 3), index=list('ps'), columns=list('qwe'))
print(df2)

"""### From Series



"""

serie1 = pd.Series([221, 222, 233], index=list('asd'))
print(serie1)

serie2 = pd.Series(["a", "b", "c"], index=list('asd'))
print(serie2)

print(pd.DataFrame({'col1': serie1, 'col2': serie2}))

serie3 = pd.Series(["a", "b", "c"], index=list('dsa'))
print(serie3)

# The first column serves as a reference for the indices
print(pd.DataFrame({'col1': serie1, 'col2': serie2, 'col3': serie3}))

serie3 = pd.Series(["a", "b", "c"], index=list('qwe'))
print(pd.DataFrame({'col1': serie1, 'col2': serie2, 'col3': serie3}))

"""### From a Dictionary



"""

pop = {'Tuscany': {'Children': 0.2, 'Youth': 0.2, 'Adults': 0.6}, 'Sicily': {'Children': 0.1, 'Youth': 0.2, 'Adults': 0.7}}
print(pd.DataFrame(pop))

"""##Methods for Pandas DataFrames



"""

np.random.seed(203)
df = pd.DataFrame(np.random.randn(25).reshape(5, 5), index=list('pluto'), columns=list('penna'))
print(df)

print(df.index)



print(df.columns)
df.columns

print(df.values)

print(df.info())

print(df.describe())

votes = np.array([12,12,13,18,18,18,18,18, 30,30,25, 29,28,29,29,29,30])
type(votes)
#votes.mean()

lista_chr = list('abcde')
df['A'] = lista_chr
print(df)
print(df.info())
print(df.describe())

df2 = pd.DataFrame([[12, 13, 14], ["q", "w", "e"]], index=list('ps'), columns=list('123'))
print(df2)
print(df2.describe())

print(df)
print(df.head(2))
print(df.tail(2))
#print(df.mean())
#print(df.max())

df = df.drop('A', axis=1)
print(df)
print(df.idxmax())
print(df.nunique())

"""To sort values, we can use the following functions:




"""

print(df)
print(df.sort_values('e'))
print(df.sort_index(ascending=False))
print(df.sort_index(ascending=True))

"""## Functions on a DataFrame
We can use apply and applymap. applymap applies the function to individual elements, while apply applies it to entire rows or columns (depending on the axis argument).




"""

print(df)
print(df.apply(sum))
print(df.apply(sum, axis=1))
print(df.apply(lambda x: x**3 + 2*x))
print(df.apply(lambda x: x > 0))

# Example to show different results between apply and applymap.
f = lambda x: np.sum(x*2 + x*3)
df_numerico = pd.DataFrame([[1, 3], [4, 2]])
print(df_numerico)

print(df_numerico.apply(f))

print(df_numerico.applymap(f))

print(df_numerico.applymap(lambda x: x**2))
print(df_numerico**2)

"""## Selecting and Slicing a Pandas DataFrame
Using the values in columns, we can extract entire columns.




"""

np.random.seed(203)
df = pd.DataFrame(np.random.randn(25).reshape(5, 5), index=list('pluto'), columns=list('penna'))
print(df)

print(df[['p']])

print(df[['p', 'e']])

print(df['p'])

print(type(df[['p']]))
print(type(df['p']))  # If we use a single square bracket, the result is a Series.

# SQL-like notation, with the DataFrame name followed by . and column name
print(df.p)

# Using a range of indices in square brackets will be interpreted as row extraction.
print(df[1:3])

# Using boolean vectors.
print(np.arange(-2, 3) > 0)

# Selecting the last two rows
print(df)
print(df[np.arange(-2, 3) > 0])
print(df[df['p'] < 0])
print(df[(df['p'] < 0) | (df['e'] > 0.7)])
print(df > 0)
print(df[df > 0])

"""## loc and iloc
With the loc and iloc functions, we can pass indices as lists of names or numerical values to get the desired rows.




"""

np.random.seed(203)
df = pd.DataFrame(np.random.randn(25).reshape(5, 5), index=list('pluto'), columns=list('penna'))
print(df)
print(df.loc[['p', 'o'], ['e', 'a']])
print(df.loc[['p', 'o'], ['n', 'a']])
print(df.iloc[[1], [2, 0]])

# If using a single list in loc and iloc, only the corresponding rows are extracted. The output is still a DataFrame if a list of names/indices is used, and a Series if a single name/index is used.
print(df.loc['l'])
print(df.iloc[1])
print(df.loc[['p', 'l']])
print(df.iloc[[1]])
print(df.loc['p':'o'])
print(df.loc[:'t'])
print(df.iloc[3:])
print(df.iloc[np.arange(2, 4)])

"""Finally, an example of how to use the rename method, already encountered for Pandas Series, to change the column names of a DataFrame using a dictionary.




"""

print(df.rename(columns={'p': 'f', 'n': 't'}))

"""## Handling Missing Data
How to handle incomplete rows in our DataFrame?




"""

df_missing = pd.DataFrame({'q': [1, 2, np.nan], 'w': [np.nan, np.nan, np.nan], 'e': [1, 2, 3]})
print(df_missing)
#print(df_missing.info())

print(df_missing.dropna())

print(df_missing)
print(df_missing.dropna(axis=0))
print(df_missing.dropna(axis=1))

print(df_missing.dropna(thresh=2))

print(df_missing.dropna(how='all', axis=1))
print(df_missing.isna())
print(df_missing.notna())

"""An alternative strategy is to insert appropriate values in place of the missing ones.



"""

print(df_missing.fillna(value='ok'))
print(df_missing['w'].fillna(value=df_missing['e'].max()))

"""# Write your own exercize!
- ex 1 ......
- ex 2 ......
- ex 3 ....

# Basic Plotting with Matplotlib
Importing Matplotlib
"""

import matplotlib.pyplot as plt

"""Creating a Simple Line Plot



"""

# Data for plotting
x = [1, 2, 3, 4, 5]
y = (2, 3, 5, 7, 11)

# Creating a line plot
plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Simple Line Plot')
plt.show()

"""### Customizing Plots
Adding Legends



"""

plt.plot(x, y, label='Prime numbers')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Line Plot with Legend')
plt.legend()
plt.show()

"""### Changing Line Styles and Colors



"""

plt.plot(y, 'y')

plt.plot(x, y, color='green', linestyle='dashdot', linewidth=1, marker='_', markerfacecolor='wheat', markersize=15)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Customized Line Plot')
plt.show()

"""### Subplots
Subplots are used to create multiple plots in a single figure.




"""

# Creating subplots
plt.figsize(40,60)
plt.subplot(2, 3, 1)
plt.plot(x, y, 'r')
plt.title('Subplot 1')

plt.subplot(2, 3, 2)
plt.plot(y, x, 'b')
plt.title('Subplot 2')

plt.subplot(2, 3, 3)
plt.plot(y, x, 'g')
plt.title('Subplot 3')

plt.subplot(2, 3, 4)
plt.plot(x, y, 'r')
plt.title('Subplot 4')

plt.subplot(2, 3, 5)
plt.plot(y, x, 'b')
plt.title('Subplot 5')

plt.subplot(2, 3, 6)
plt.plot(y, x, 'g')
plt.title('Subplot 6')

plt.show()

"""### Scatter Plot
Scatter plots are used to plot data points.




"""

# Data for scatter plot
x = [1, 2, 3, 4, 5]
y = [2, 4, 1, 3, 5]

plt.scatter(x, y, color='red')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Scatter Plot')
plt.show()

"""### Bar Plot
Bar plots are used to represent data with rectangular bars.




"""

# Data for bar plot
categories = ['A', 'B', 'C', 'D', 'E']
values = [4, 7, 1, 8, 5]

plt.bar(categories, values, color='blue')

plt.title('Bar Plot')
plt.xlabel('Categories')
plt.ylabel('Values')
plt.show()

"""### Histogram
Histograms are used to represent the distribution of numerical data.




"""

# Data for histogram
data = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 10]

plt.hist(data, bins=5, color='purple')
plt.xlabel('Data')
plt.ylabel('Frequency')
plt.title('Histogram')
plt.show()

"""### Pie Chart
Pie charts are used to represent data in a circular graph.




"""

# Data for pie chart
labels = ['A', 'B', 'C', 'D']
sizes = [5, 6, 79, 10]

plt.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=140)
plt.title('Pie Chart')
plt.show()

"""Adding Grid Lines



"""

plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot with Grid Lines')
plt.grid(True, linewidth=3)
plt.show()

"""Adjusting Axes Limits



"""

plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title

"""#### Adjusting Axes Limits


"""

plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot with Adjusted Axes Limits')
plt.xlim(0, 6)
plt.ylim(0, 12)
plt.show()

"""### Adding Annotations



"""

plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot with Annotations')
plt.annotate('Highest point', xy=(5, 11), xytext=(3, 9),
             arrowprops=dict(facecolor='black', shrink=0.05))
plt.show()

"""Adding Text



"""

plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot with Text')
plt.text(2, 7, 'Nel mezzo del cammin di nostra vita', fontsize=12, color='blue')
plt.show()

"""Changing Figure Size



"""

plt.figure()

plt.figure(figsize=(20, 5))
plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot with Custom Figure Size')
plt.show()

"""Changing Axis Ticks



"""

plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot with Custom Axis Ticks')
plt.xticks([1, 2, 3, 4, 5], ['One', 'Two', 'Three', 'Four', 'Five'])
plt.yticks((2, 4, 6, 8, 10),('Two', 'Four', 'Six', 'Eight', 'Ten'))
plt.yticks({2:'Two', 4:'Four', 6:'Six', 8:'Eight', 10:'Ten'})

#plt.yticks(['Two', 'Four', 'Six', 'Eight', 'Ten'])

plt.show()

"""Using Logarithmic Scale



"""

# Data for plotting
x = [1, 2, 3, 4, 5]
y = (2, 3, 5, 7, 11)

# Data for plotting
x = [1, 2, 3, 4, 5]
y = (20, 300, 5000, 30000, 110000)

plt.plot(x, y, '+')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot with Logarithmic Scale')
plt.yscale('log')
plt.show()

"""### Saving Plots
You can save plots to files using savefig().

Saving as PNG



"""

plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot to Save')
plt.savefig('plot.png')
plt.show()

"""Saving as PDF



"""

plt.plot(x, y)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Plot to Save as PDF')
plt.savefig('plot.pdf')
plt.show()

"""### Plotting Multiple Lines
You can plot multiple lines on the same graph.




"""

# Data for multiple lines
x = [1, 2, 3, 4, 5]
y1 = [2, 3, 5, 7, 11]
y2 = [1, 4, 6, 8, 10]

plt.plot(x, y1, label='Line 1', color='blue')
plt.plot(x, y2, label='Line 2', color='red')
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Multiple Lines Plot')
plt.legend()
plt.show()

"""### Adding Error Bars
Error bars provide a graphical representation of the variability of data.




"""

# Data with error bars
x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]
errors = [0.5, 0.4, 0.6, 0.7, 0.8]

plt.errorbar(x, y, yerr=errors, xerr=errors, fmt='-o', ecolor='red', capsize=16)
plt.xlabel('X-axis')
plt.ylabel('Y-axis')
plt.title('Error Bars')
plt.show()

"""## Creating 3D Plots
Matplotlib can create 3D plots using the Axes3D module.




"""

from mpl_toolkits.mplot3d import Axes3D



fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
# Data for 3D plot
x = [1, 2, 3, 4, 5]
y = [2, 3, 5, 7, 11]
z = [1, 4, 9, 16, 25]

ax.plot(x, y, z)
ax.set_xlabel('X-axis')
ax.set_ylabel('Y-axis')
ax.set_zlabel('Z-axis')
ax.set_title('3D Plot')
plt.show()

"""# Data Visualization with Seaborn

## Introduction
Seaborn is a Python visualization library based on Matplotlib that provides a high-level interface for drawing attractive and informative statistical graphics.


"""

import seaborn as sns
import matplotlib.pyplot as plt

"""#### Loading Datasets
Seaborn comes with several built-in datasets that you can use to practice.




"""

# Load the tips dataset
tips = sns.load_dataset('tips')
print(tips.head())

"""### Basic Plotting with Seaborn
Scatter Plot



"""

# Scatter plot with Seaborn
sns.scatterplot(x='total_bill', y='tip', data=tips)
plt.title('Scatter Plot of Total Bill vs Tip')
plt.show()

"""Histogram



"""

# Histogram with Seaborn
sns.histplot(tips['total_bill'], kde=True)
plt.title('Histogram of Total Bill')
plt.show()

tips.describe().total_bill

"""Box Plot



"""

# Box plot with Seaborn
sns.boxplot(x='day', y='total_bill', data=tips)
plt.title('Box Plot of Total Bill by Day')
plt.show()

"""Bar Plot



"""

# Bar plot with Seaborn
sns.barplot(x='day', y='total_bill', data=tips, errorbar=None)
plt.title('Bar Plot of Average Total Bill by Day')
plt.show()

"""### Advanced Plotting with Seaborn
Pair Plot

"""

# Pair plot with Seaborn
sns.pairplot(tips)
plt.title('Pair Plot of Tips Dataset')
plt.show()

"""Heatmap



"""

# Select only numeric columns for correlation matrix
numeric_tips = tips.select_dtypes(include=['float64', 'int64'])

# Correlation matrix
corr = numeric_tips.corr()

# Heatmap with Seaborn
sns.heatmap(corr, annot=False, cmap='coolwarm', center=0)
plt.title('Heatmap of Correlation Matrix')
plt.show()

"""Violin Plot

"""

# Violin plot with Seaborn
sns.violinplot(x='day', y='total_bill', data=tips)
plt.title('Violin Plot of Total Bill by Day')
plt.show()

"""### Customizing Seaborn Plots
Adding Titles and Labels

"""

# Scatter plot with title and labels
sns.scatterplot(x='total_bill', y='tip', data=tips)
plt.title('Total Bill vs Tip')
plt.xlabel('Total Bill')
plt.ylabel('Tip')
plt.show()

"""Changing Color Palettes


"""

# Bar plot with custom color palette
sns.barplot(x='day', y='total_bill', data=tips, palette='viridis', ci=None)
plt.title('Bar Plot with Custom Color Palette')
plt.show()

"""You can save plots to files using savefig().

Saving as PNG
"""

sns.scatterplot(x='total_bill', y='tip', data=tips)
plt.title('Total Bill vs Tip')
plt.savefig('scatter_plot.png')
plt.show()

"""Saving as PDF

"""

sns.scatterplot(x='total_bill', y='tip', data=tips)
plt.title('Total Bill vs Tip')
plt.savefig('scatter_plot.pdf')
plt.show()

"""## Plotly

"""

import plotly.express as px
import plotly.graph_objects as go

"""Basic Plotting with Plotly
Scatter Plot

"""

# Scatter plot with Plotly
fig = px.scatter(tips, x='total_bill', y='tip', title='Scatter Plot of Total Bill vs Tip')
fig.show()

"""Histogram

"""

# Histogram with Plotly
fig = px.histogram(tips, x='total_bill', title='Histogram of Total Bill', nbins=20)
fig.show()

"""Box Plot

"""

# Box plot with Plotly
fig = px.box(tips, x='day', y='total_bill', title='Box Plot of Total Bill by Day')
fig.show()

"""Bar Plot

"""

# Bar plot with Plotly
fig = px.bar(tips, x='day', y='total_bill', title='Bar Plot of Average Total Bill by Day')
fig.show()

"""Advanced Plotting with Plotly

Plotly does not have a direct equivalent of Seaborn's pairplot, but you can create similar plots using subplots.




"""

import plotly.figure_factory as ff

# Pair plot with Plotly
fig = ff.create_scatterplotmatrix(tips[['total_bill', 'tip', 'size']], diag='histogram', title='Pair Plot of Tips Dataset')
fig.show()

"""Heatmap

"""

# Select only numeric columns for correlation matrix
numeric_tips = tips.select_dtypes(include=['float64', 'int64'])

# Correlation matrix
corr = numeric_tips.corr()

# Heatmap with Plotly
fig = go.Figure(data=go.Heatmap(z=corr.values, x=corr.index.values, y=corr.columns.values, colorscale='Viridis'))
fig.update_layout(title='Heatmap of Correlation Matrix')
fig.show()

"""Violin Plot

"""

# Violin plot with Plotly
fig = px.violin(tips, x='day', y='total_bill', title='Violin Plot of Total Bill by Day')
fig.show()

"""Customizing Plotly Plots
Adding Titles and Labels



"""

# Scatter plot with title and labels
fig = px.scatter(tips, x='total_bill', y='tip', title='Total Bill vs Tip')
fig.update_layout(xaxis_title='Total Bill', yaxis_title='Tip')
fig.show()

"""Changing Color Palettes

"""

# Bar plot with custom color palette
fig = px.bar(tips, x='day', y='total_bill', color='day', title='Bar Plot with Custom Color Palette')
fig.update_layout(coloraxis_showscale=False)
fig.show()

"""Saving Plots
You can save plots to files using write_image().


"""

#Saving as PNG

fig = px.scatter(tips, x='total_bill', y='tip', title='Total Bill vs Tip')
fig.write_image('scatter_plot.png')

#Saving as HTML

fig = px.scatter(tips, x='total_bill', y='tip', title='Total Bill vs Tip')
fig.write_html('scatter_plot.html')

"""## Seaborn
### Strengths
- Easy to Use: Seaborn provides a high-level interface for drawing attractive and informative statistical graphics.
- Statistical Plots: Seaborn is particularly well-suited for creating statistical plots, such as pair plots, violin plots, and heatmaps.
- Integration with Matplotlib: Seaborn is built on top of Matplotlib, making it easy to customize plots using Matplotlib's extensive capabilities.
### Weaknesses
- Interactivity: Seaborn plots are static by default and do not support interactivity out of the box.
- Customization: While Seaborn offers a high-level interface, it can be less flexible than Matplotlib for highly customized plots.
##Plotly
### Strengths
- Interactivity: Plotly plots are interactive by default, making it easy to explore data visually.
- Complex Visualizations: Plotly excels at creating complex visualizations, such as 3D plots, geographic maps, and interactive dashboards.
- Ease of Sharing: Plotly plots can be easily shared as HTML files, making them accessible in web browsers without additional software.
###Weaknesses
- Learning Curve: Plotly can have a steeper learning curve for users who are not familiar with its syntax and features.
- Statistical Plots: While Plotly can create statistical plots, it is not as specialized in this area as Seaborn.
- Comparing Seaborn and Plotly
### Ease of Use
- Seaborn: Provides a simpler, high-level interface for creating standard statistical plots.
- Plotly: Requires more code for some basic plots but offers extensive customization and interactivity.
### Interactivity
- Seaborn: Static plots; requires additional libraries (e.g., mpld3) for interactivity.
- Plotly: Interactive plots by default; supports zooming, panning, and tooltips.
### Customization
- Seaborn: Built on Matplotlib, allowing for extensive customization using Matplotlib's functions.
- Plotly: Highly customizable with a wide range of options for layout, styling, and interactivity.
### Use Cases
- Seaborn: Ideal for quick, exploratory data analysis and creating standard statistical plots.
- Plotly: Best for creating interactive visualizations, complex plots, and sharing visualizations online.

# Exercises on Pandas, Matplotlib, Plotly, and Seaborn

## Pandas Exercises

### Exercise 1: Creating Series
Create a Pandas Series from a list of numbers `[10, 20, 30, 40, 50]` and use custom indices `['a', 'b', 'c', 'd', 'e']`.

### Exercise 2: Accessing Series Elements
Create a Series from the dictionary `{'A': 10, 'B': 20, 'C': 30}`. Access the element with index 'B'.

### Exercise 3: Series Methods
Create a Series from a NumPy array of 10 random integers between 1 and 100. Use the `.describe()` method to get summary statistics.

### Exercise 4: Creating DataFrame
Create a DataFrame from the list of lists `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` with row indices `['a', 'b', 'c']` and column names `['X', 'Y', 'Z']`.

### Exercise 5: DataFrame Operations
Load the `tips` dataset from Seaborn and perform the following operations:
- Display the first 5 rows.
- Show the summary statistics of the dataset.
- Group the data by 'day' and calculate the mean tip amount for each day.

### Exercise 6: Handling Missing Data
Create a DataFrame with some missing values and fill the missing values with the mean of the column.

### Exercise 7: Merging DataFrames
Create two DataFrames and merge them on a common column.

# Example DataFrames
df1 = pd.DataFrame({'key': ['A', 'B', 'C', 'D'], 'value1': [1, 2, 3, 4]})
df2 = pd.DataFrame({'key': ['B', 'D', 'E', 'F'], 'value2': [5, 6, 7, 8]})

## Matplotlib Exercises
###Exercise 1: Basic Line Plot
Create a line plot for the following data: x = [0, 1, 2, 3, 4, 5] and y = [0, 1, 4, 9, 16, 25].

###Exercise 2: Customizing Plot
Create a scatter plot for the data x = [1, 2, 3, 4, 5] and y = [2, 4, 6, 8, 10]. Add title, axis labels, and grid lines.

###Exercise 3: Subplots
Create a figure with 2 subplots: one for a sine wave and one for a cosine wave over the range 0 to 2π.

###Exercise 4: Bar Plot
Create a bar plot for the categories ['A', 'B', 'C', 'D'] with values [4, 7, 1, 8].

###Exercise 5: Saving Plot
Create a histogram of 100 random numbers and save the plot as histogram.png.

## Plotly Exercises
###Exercise 1: Interactive Scatter Plot
Create an interactive scatter plot using Plotly for the tips dataset with total_bill on the x-axis and tip on the y-axis.

###Exercise 2: Interactive Histogram
Create an interactive histogram for the total_bill column in the tips dataset.

###Exercise 3: Interactive Box Plot
Create an interactive box plot for total_bill grouped by day in the tips dataset.

###Exercise 4: Interactive Bar Plot
Create an interactive bar plot for the average total_bill by day in the tips dataset.

###Exercise 5: Saving Plotly Plot
Create a scatter plot for total_bill and tip and save the plot as an HTML file.

## Seaborn Exercises
###Exercise 1: Basic Scatter Plot
Create a scatter plot using Seaborn for the tips dataset with total_bill on the x-axis and tip on the y-axis.

###Exercise 2: Customizing Seaborn Plot
Create a box plot for total_bill by day in the tips dataset. Add title and axis labels.

###Exercise 3: Pair Plot
Create a pair plot for the tips dataset.

###Exercise 4: Heatmap
Create a heatmap for the correlation matrix of the tips dataset.

###Exercise 5: Violin Plot
Create a violin plot for total_bill by day in the tips dataset.
"""